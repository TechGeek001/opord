/** TO DO
icon determines if this is equipment or a unit

fix positioning for diamonds (rotation) for larger units. Border padding is an unreliable modifier size for > 0
**/
function Unit(identity, icon, size, modifiers, amplifiers, options) {
	// -------------------------------- Class-specified Options --------------------------------- //
	this.error = false;			// Set to true if there was an error building this unit (will not draw)
	this.viewport = false;		// The SVG element that this element exists in
	this.position = {			// The top-left position of the unit symbol
		x: 0,
		y: 0
	};
	this.sizes = {				// Preset widths for the frame (assumes friendly unit, all others modified in draw())
		0: {
			w: 90,
			s: 2
		},
		1: {
			w: 120,
			s: 3
		},
		2: {
			w: 150,
			s: 4
		},
		3: {
			w: 180,
			s: 4.5
		},
		4: {
			w: 210,
			s: 5
		},
		5: {
			w: 240,
			s: 6
		}
	}
	this.stroke = {
		border: "solid",		// The border to use on unit frames
		color: false			// The color to use on this icon
	}
	
	// --------------------------------- User-specified Options --------------------------------- //
	this.uFrame = false;		// The type of unit frame to use
	this.eFrame = false;		// The type of equipment frame to use
	this.type = "unit";			// The type of symbol this is
	this.icon = false;			// The type of unit/equipment this is
	this.size = false;			// The size of the unit (squad, platoon, company)
	this.amplifiers = {
		r1: false,				// Indicates whether the unit is reinforced, detached, or both
		r2: false,				// An accepted code that shows the country indicator
		r3: false,				// A unique alphanumeric designation that identifies the unit being displayed
		r4: false,				// Number or title of the next higher formation of the unit being displayed
		r5: false,				// Free text staff comments for information required by the commander / unit location
		r7: false,				// Quantity that identifies the number of items present (equipment)
		r8: false,				// Task force amplifier placed over the echelon
		r9: false,				// Feint or dummy indicator
		r12: false,				// Combat effectiveness of unit or equipment displayed
		r13: false,				// Mobility indicator of the equipment being displayed
	}
	this.modifiers = {
		s1: false,				// Top sector modifier
		s2: false				// Bottom sector modifier
	}
	this.options = {
		fill: true,				// Show transparent icons if false (Concept sketch), filled if true (ops graphics)
		version: 1,				// v0 per FM 1-02 (SEP04), v1 per ADRP 1-02 (FEB15)
		size: 0					// Size of unit icons
	}
	
	// ---------------------------------- Graphics Requirements --------------------------------- //
	this.iconGraphics = {
		// Cavalry
		cavalry: new Array(
			{
				type: "line",
				w: 1,
				h: 1,
				x1: 0,
				y1: 1,
				x2: 1,
				y2: 0,
				p: 0,
				fullFrame: true
			}
		),
		// Infantry
		infantry: new Array(
			{
				type: "line",
				w: 1,
				h: 1,
				x1: 0,
				y1: 0,
				x2: 1,
				y2: 1,
				p: 0,
				fullFrame: true
			},
			{
				type: "line",
				w: 1,
				h: 1,
				x1: 0,
				y1: 1,
				x2: 1,
				y2: 0,
				p: 0,
				fullFrame: true
			}
		),
		// Missile (NATO)
		missile: new Array(
			{
				type: "curve",
				w: .33,
				h: .165,
				p: 1,
				apex: "top",
				fullFrame: false
			},
			{
				type: "line",
				w: .33,
				h: 1,
				x1: .33,
				y1: .125,
				x2: .33,
				y2: 1,
				p: 2,
				fullFrame: false
			},
			{
				type: "line",
				w: .33,
				h: 1,
				x1: .66,
				y1: .125,
				x2: .66,
				y2: 1,
				p: 2,
				fullFrame: false
			},
			{
				type: "line",
				w: .33,
				h: 1,
				x1: .5,
				y1: 0,
				x2: .5,
				y2: 1,
				p: 2,
				fullFrame: false
			}
		)
	}
	//--------------------------------------------------------------------------------------------//
	this.setIdentity(identity).setIcon(icon).setSize(size);
}

Unit.prototype.setIdentity = function(s) {
	var error = new Array(
		"The Identity should be either \"friendly\", \"friendly assumed\", \"hostile\", \"hostile suspect\", \"neutral\", \"unknown\", or \"unknown pending\", got \"" + s + "\"."
	);
	var identities = {
		friendly: {
			color: "blue",
			u: "rect",
			e: "circle",
			ur: 1.5,
			er: 1
		},
		hostile: {
			color: "red",
			u: "diamond",
			e: "diamond",
			ur: 1,
			er: 1
		},
		neutral: {
			color: "green",
			u: "square",
			e: "square",
			ur: 1,
			er: 1
		},
		unknown: {
			color: "yellow",
			u: "cloud",
			e: "cloud",
			ur: 1,
			er: 1
		}
	}
	// See if the type of frame is valid based on the frames object
	if(typeof s === "string") {
		// Split the main type from the modifier (e.g. "friendly" and "friendly assumed")
		var type = s.split(" ");
		// If the type exists, set the values
		if(typeof identities[type[0]] !== "undefined") {
			this.uFrame = identities[type[0]].u;
			this.eFrame = identities[type[0]].e;
			this.stroke.color = identities[type[0]].color;
			// Set the border type (solid if undefined, dashed if assumed, suspect, or pending)
			if(typeof type[1] === "undefined") {
				this.stroke.border = "solid";
			} else if(s == "friendly assumed" || s == "hostile suspect" || s == "unknown pending") {
				this.stroke.border = "dash";
			} else {
				console.error(error[0]);
			}
		// Else, generate an error
		} else {
			console.error(error[0]);
			this.error = true;
		}
	// Else, generate an error
	} else {
		console.error(error[0]);
		this.error = true;
	}
	return this;
}

Unit.prototype.setIcon = function(s) {
	var choices = "";
	var i = 0;
	for(var k in this.iconGraphics) {
		if(i > 0) {
			choices += ", ";
		}
		choices += "\"" + k + "\"";
		i++;
	}
	var error = new Array("The Icon should be any of the following: " + choices + ", got \"" + s + "\".");
	
	if(typeof this.iconGraphics[s] !== 'undefined') {
		this.icon = s;
	} else {
		console.error(error[0]);
		this.error = true;
	}
	return this;
}

Unit.prototype.setSize = function(s) {
	var sizes = new Array("team", "squad", "section", "platoon", "company", "battalion", "regiment");
	var choices = "";
	for(var i = 0; i < sizes.length; i++) {
		if(i > 0) {
			choices += ", ";
		}
		choices += "\"" + sizes[i] + "\"";
	}
	var error = new Array("The Size should be any of the following: " + choices + ", got \"" + s + "\".");
	
	if(sizes.indexOf(s) >= 0) {
		this.size = s;
	} else {
		console.error(error[0]);
		this.error = true;
	}
	return this;
}

Unit.prototype.setSector = function(s) {
	
	return this;
}

Unit.prototype.setAmplifier = function(s) {
	
	return this;
}

Unit.prototype.draw = function(GraphicsBuilder, x, y) {
	// CIRCLE
	var drawCircle = function(cx, cy, r, borderType, borderWidth, borderColor, fill) {
		var c = document.createElementNS(xmlns, "circle");
		c.setAttributeNS(null, "cx", cx);
		c.setAttributeNS(null, "cy", cy);
		c.setAttributeNS(null, "r", r);
		if(borderType == "dash") {
			c.setAttributeNS(null, "stroke-dasharray", "5, 5");
		}
		if(!isNaN(borderWidth)) {
			c.setAttributeNS(null, "stroke-width", borderWidth);
		}
		if(typeof borderColor !== "undefined") {
			c.setAttributeNS(null, "stroke", borderColor);
		}
		if(typeof fill !== "undefined") {
			c.setAttributeNS(null, "fill", fill);
		}
		toDraw.push(c);
	}
	// CURVE
	var drawCurve = function(x1, y1, x2, y2) {
		var p = document.createElementNS(xmlns, "path");
		p.setAttributeNS(null, "d", "M" + x1 + "," + y2 + " C" + x1 + "," + y1 + " " + x2 + "," + y1 + " " + x2 + "," + y2);
		toDraw.push(p);
	}
	// LINE
	var drawLine = function(x1, y1, x2, y2, width, color) {
		var l = document.createElementNS(xmlns, "line");
		l.setAttributeNS(null, "x1", x1);
		l.setAttributeNS(null, "y1", y1);
		l.setAttributeNS(null, "x2", x2);
		l.setAttributeNS(null, "y2", y2);
		if(!isNaN(width)) {
			l.setAttributeNS(null, "stroke-width", width);
		}
		if(typeof color !== "undefined") {
			l.setAttributeNS(null, "stroke", color);
		}
		toDraw.push(l);
	}
	// RECT
	var drawRect = function(x, y, w, h, borderType, borderWidth, borderColor, fill, rotate) {
		var r = document.createElementNS(xmlns, "rect");
		r.setAttributeNS(null, "x", x);
		r.setAttributeNS(null, "y", y);
		r.setAttributeNS(null, "width", w);
		r.setAttributeNS(null, "height", h);
		if(borderType !== false && borderType == "dash") {
			r.setAttributeNS(null, "stroke-dasharray", "5, 5");
		}
		if(borderWidth !== false && !isNaN(borderWidth)) {
			r.setAttributeNS(null, "stroke-width", borderWidth);
		}
		if(borderColor !== false && typeof borderColor !== "undefined") {
			r.setAttributeNS(null, "stroke", borderColor);
		}
		if(fill !== false && typeof fill !== "undefined") {
			r.setAttributeNS(null, "fill", fill);
		}
		if(typeof rotate !== "undefined") {
			r.setAttributeNS(null, "transform", "rotate(" + rotate + ")");
		}
		toDraw.push(r);
	}
	//--------------------------------------------------------------------------------------------//
	/**
		Curve Declaration:
			type: "curve",	// The type is a curve
			w: .33,			// The left edge of this shape as a percentage of its container's width
			h: .165,		// The top edge of this shape as a percentage of its container's height
			p: 1,			// The padding, expressed as a multiplier to the border width
			apex: "top",	// Which direction the curve points
			c: "icon"		// The container, either the icon (octagon) or the frame (the rectangle, circle, diamond, square, or cloud)
		Line Declaration:
			type: "line",	// The type is a line
			x1: 0,			// The x1 coordinate, as a percentage of its container's width
			y1: 0,			// The y1 coordinate, as a percentage of its container's width
			x2: 1,			// The x2 coordinate, as a percentage of its container's width
			y2: 1,			// The y2 coordinate, as a percentage of its container's width
			p: 0,			// The padding, expressed as a multiplier to the border width
			c: "frame"		// The container, either the icon (octagon) or the frame (the rectangle, circle, diamond, square, or cloud)
	**/
	//--------------------------------------------------------------------------------------------//
	if(!this.error) {
		var iconGraphics = this.iconGraphics;
		var toDraw = new Array();
		var xmlns = "http://www.w3.org/2000/svg";
		// Create or clear the SVG group
		if(this.viewport == false) {
			this.viewport = document.createElementNS(xmlns, "svg");
		} else {
			this.viewport.innerHTML = "";
		}
		// Set the positioning if it exists
		var g = document.createElementNS(xmlns, "g");
		g.setAttributeNS(null, "draggable", "true");
		x = typeof x !== "undefined" ? x:0;
		y = typeof y !== "undefined" ? y:0;
		
		g.setAttributeNS(null, "transform", "translate(" + x + "," + y + ")");
		g.setAttributeNS(null, "transX", x);
		g.setAttributeNS(null, "transY", y);
		
		g.addEventListener("mousedown", function(e) {
			if(GraphicsBuilder.draggable) {
				GraphicsBuilder.moveAction = "unit";
				GraphicsBuilder.lastX = e.x;
				GraphicsBuilder.lastY = e.y;
				GraphicsBuilder.draggingElement = this;
			}
		});
		
		// Set the dimensions for the sub-elements
		var s = this.options.size;
		// Determine key sizes
		switch(this.uFrame) {
			case("rect"):
				var w = this.sizes[s].w;		// Frame width
				var h = w / 1.5;				// Frame height
				break;
			case("diamond"):
				var w = this.sizes[s].w;
				var h = parseInt(Math.sqrt(Math.pow((this.sizes[s].w / 1.5) * .66, 2) * 2));
				break;
		}
		var iconDim = h;			// Sets the height for the bounding octagon
		var b = this.sizes[s].s		// Border width
		
		// Set basic colors
		var c = this.stroke.color;
		if(this.options.fill) {
			g.setAttributeNS(null, "fill", c);
			g.setAttributeNS(null, "stroke", "black");
		} else {
			g.setAttributeNS(null, "fill", "transparent");
			g.setAttributeNS(null, "stroke", c);
		}
		g.setAttributeNS(null, "stroke-width", this.sizes[s].s);
		
		// Set the top-left corners for elements
		var d = {
			frame: {
				x: b,			// X is offset right by the frame border (stroke)
				y: h / 3 + b	// Y is offset down by 1/3 the height plus the frame border (stroke)
			},
			size: {
				x: b,
				y: (h / 3) - (h / 4)
			}
			
		}
		// Determine if this is a unit or equipment
		if(this.type == "unit") {
			// Create the frame
			switch(this.uFrame) {
				case "rect":
					drawRect(d.frame.x, d.frame.y, w - b, h - b, this.stroke.border);
					break;
				case "diamond":
					drawRect(d.frame.x + ((w / 1.5) / 3) - (1.5 * b), d.frame.y + (h / 4), h - b, h - b, false, false, false, false, "45 " + (d.frame.x + ((w / 1.5) / 3) + (h / 2) - (1.5 * b)) + " " + (d.frame.y + (h * .75) - (1.5 * b)));
					break;
				case "square":
					break;
				case "cloud":
					break;
			}
			// Create the icon
			for(var i = 0; i < iconGraphics[this.icon].length; i++) {
				var width = iconGraphics[this.icon][i].fullFrame ? w - b:iconDim - b;
				var height = iconGraphics[this.icon][i].fullFrame ? h - b:iconDim - b;
				var iconHorOffset = iconGraphics[this.icon][i].fullFrame ? 0:(w - iconDim) / 2;
				var iconVerOffset = 0;
				
				if(this.uFrame == "diamond" || this.uFrame == "cloud") {
					/** TODO **/
					iconVerOffset = (h / 3) - b + (height / 6);
					iconHorOffset += (width / 6) + (2 * b);
					width = (width * .66) - (4 * b);
					height = (height * .66) - (4 * b);
					/** END TODO **/
				}
				
				switch(iconGraphics[this.icon][i].type) {
					case "curve":
						if(iconGraphics[this.icon][i].apex == "top") {
							var x1 = (width * iconGraphics[this.icon][i].w) + iconHorOffset + b;
							var x2 = x1 + (width * iconGraphics[this.icon][i].w);
							var y1 = (b * iconGraphics[this.icon][i].p) + d.frame.y + (.25 * b) + iconVerOffset;
							var y2 = (iconDim * iconGraphics[this.icon][i].h) + y1 + iconVerOffset;
						}
						drawCurve(x1, y1, x2, y2);
						break;
					case "line":
						var x1 = iconHorOffset + (width * iconGraphics[this.icon][i].x1) + b;
						var x2 = iconHorOffset + (width * iconGraphics[this.icon][i].x2) + b;
						var y1 = ((height * iconGraphics[this.icon][i].h) * iconGraphics[this.icon][i].y1) + d.frame.y + (b * iconGraphics[this.icon][i].p) + iconVerOffset;
						var y2 = ((height * iconGraphics[this.icon][i].h) * iconGraphics[this.icon][i].y2) + d.frame.y - (b * iconGraphics[this.icon][i].p) + iconVerOffset;
						drawLine(x1, y1, x2, y2);
						break;
				}
			}
			// Create the size (echelon) icon
			var s1 = (h / 4) - b;	// The width and height for each icon for circles (SQD, SEC, PLT) and x's (BDE+)
			var s2 = (h / 4) + b;	// The height for each icon for vertical lines (CO, BN, REGT)
			if(this.options.fill) {
				var sizeFill = "black";
			} else {
				var sizeFill = c;
			}
			switch(this.size) {
				case("team"):
					drawCircle(w / 2, d.size.y + ((h / 4) / 2), (s1 / 2) - (b / 2), null, b, sizeFill, "transparent");
					drawLine((w / 2) + (s1 / 2), d.size.y + b, (w / 2) - (s1 / 2), d.size.y + s1);
					break;
				case("squad"):
					drawCircle(w / 2, d.size.y + ((h / 4) / 2), (s1 / 2), null, 0, null, sizeFill);
					break;
				case("section"):
					drawCircle((w / 2) - ((s1 / 2) + (b / 2)), d.size.y + ((h / 4) / 2), s1 / 2, null, 0, null, sizeFill);
					drawCircle((w / 2) + ((s1 / 2) + (b / 2)), d.size.y + ((h / 4) / 2), s1 / 2, null, 0, null, sizeFill);
					break;
				case("platoon"):
					drawCircle(w / 2, d.size.y + ((h / 4) / 2), s1 / 2, null, 0, null, sizeFill);
					drawCircle((w / 2) - (s1 + b), d.size.y + ((h / 4) / 2), s1 / 2, null, 0, null, sizeFill);
					drawCircle((w / 2) + (s1 + b), d.size.y + ((h / 4) / 2), s1 / 2, null, 0, null, sizeFill);
					break;
				case("company"):
					drawLine(w / 2, d.size.y + (b / 2), w / 2, d.size.y + s2, 2 * b);
					break;
				case("battalion"):
					drawLine((w / 2) - (b * 2), d.size.y + (b / 2), (w / 2) - (b * 2), d.size.y + s2, 2 * b);
					drawLine((w / 2) + (b * 2), d.size.y + (b / 2), (w / 2) + (b * 2), d.size.y + s2, 2 * b);
					break;
				case("regiment"):
					drawLine(w / 2, d.size.y + (b / 2), w / 2, d.size.y + s2, 2 * b);
					drawLine((w / 2) - (b * 4), d.size.y + (b / 2), (w / 2) - (b * 4), d.size.y + s2, 2 * b);
					drawLine((w / 2) + (b * 4), d.size.y + (b / 2), (w / 2) + (b * 4), d.size.y + s2, 2 * b);
					break;
			}
		} else {
			// ICON
		}
		// Add the elements to the group
		for(var i = 0; i < toDraw.length; i++) {
			g.appendChild(toDraw[i]);
		}
		// Append the group to the canvas
		this.viewport = g;
		GraphicsBuilder.canvas.appendChild(this.viewport);
	} else {
		console.error("Failed to draw Unit due to errors in its parameters. Check the error log for more details.");
	}
	return this;
}